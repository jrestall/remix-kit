import { promises as fsp } from 'node:fs';
import { isAbsolute, join, relative, resolve } from 'pathe';
import type { Remix, TSReference } from '@remix-kit/schema';
import { defu } from 'defu';
import type { TSConfig } from 'pkg-types';
import { getModulePaths, getNearestPackage } from '@remix-kit/kit';

export const writeTypes = async (remix: Remix) => {
  const modulePaths = getModulePaths(remix.options.modulesDir);

  const tsConfig: TSConfig = defu(remix.options.typescript?.tsConfig, {
    compilerOptions: {
      jsx: 'preserve',
      target: 'ESNext',
      module: 'ESNext',
      moduleResolution: 'Node',
      skipLibCheck: true,
      strict: remix.options.typescript?.strict ?? false,
      allowJs: true,
      noEmit: true,
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      types: ['node'],
      baseUrl: relative(remix.options.buildDir, remix.options.rootDir),
      paths: {},
    },
    include: [
      './remix.d.ts',
      join(relative(remix.options.buildDir, remix.options.rootDir), '**/*'),
      ...(remix.options.srcDir !== remix.options.rootDir
        ? [join(relative(remix.options.buildDir, remix.options.srcDir), '**/*')]
        : []),
      ...(remix.options.typescript.includeWorkspace &&
      remix.options.workspaceDir !== remix.options.rootDir
        ? [join(relative(remix.options.buildDir, remix.options.workspaceDir), '**/*')]
        : []),
    ],
    exclude: [],
  });

  const aliases: Record<string, string> = {
    ...remix.options.alias,
    '#build': remix.options.buildDir,
  };

  for (const alias in aliases) {
    const relativePath = isAbsolute(aliases[alias])
      ? relative(remix.options.rootDir, aliases[alias]) || '.'
      : aliases[alias];

    const stats = await fsp
      .stat(resolve(remix.options.rootDir, relativePath))
      .catch(() => null /* file does not exist */);
    tsConfig.compilerOptions = tsConfig.compilerOptions || {};
    if (stats?.isDirectory()) {
      tsConfig.compilerOptions.paths[alias] = [relativePath];
      tsConfig.compilerOptions.paths[`${alias}/*`] = [`${relativePath}/*`];
    } else {
      tsConfig.compilerOptions.paths[alias] = [
        relativePath.replace(/(?<=\w)\.\w+$/g, ''),
      ]; /* remove extension */
    }
  }

  const references: TSReference[] = [...remix.options.modules, ...remix.options._modules]
    .filter((f) => typeof f === 'string')
    .map((id) => ({ types: getNearestPackage(id, modulePaths)?.name || id }));

  const declarations: string[] = [];

  await remix.callHook('prepare:types', { references, declarations, tsConfig });

  const declaration = [
    ...references.map((ref) => {
      if ('path' in ref && isAbsolute(ref.path)) {
        ref.path = relative(remix.options.buildDir, ref.path);
      }
      return `/// <reference ${renderAttrs(ref)} />`;
    }),
    ...declarations,
    '',
    'export {}',
    '',
  ].join('\n');

  async function writeFile() {
    const GeneratedBy = '// Generated by Remix';

    const tsConfigPath = resolve(remix.options.buildDir, 'tsconfig.json');
    await fsp.mkdir(remix.options.buildDir, { recursive: true });
    await fsp.writeFile(tsConfigPath, GeneratedBy + '\n' + JSON.stringify(tsConfig, null, 2));

    const declarationPath = resolve(remix.options.buildDir, 'remix.d.ts');
    await fsp.writeFile(declarationPath, GeneratedBy + '\n' + declaration);
  }

  await writeFile();
};

function renderAttrs(obj: Record<string, string>) {
  return Object.entries(obj)
    .map((e) => renderAttr(e[0], e[1]))
    .join(' ');
}

function renderAttr(key: string, value: string) {
  return value ? `${key}="${value}"` : '';
}
